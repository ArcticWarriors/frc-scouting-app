# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Bookmark implements Node {
  id: ID!
  submitter(where: UserWhereInput): User!
  team(where: TeamWhereInput): Team!
  grouping: String!
}

type Image implements Node {
  id: ID!
  path: String!
  name: String!
  submitter(where: UserWhereInput): User!
  owner(where: ScoutTeamWhereInput): ScoutTeam!
  private: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MatchData implements Node {
  id: ID!
  team(where: TeamWhereInput): Team
  alliance: Alliance
  match(where: MatchWhereInput): Match!
  field(where: MatchFieldWhereInput): MatchField!
  value: String!
  owner(where: ScoutTeamWhereInput): ScoutTeam!
  private: Boolean
  submitter(where: UserWhereInput): User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MatchPlacement implements Node {
  id: ID!
  match(where: MatchWhereInput): Match!
  team(where: TeamWhereInput): Team!
  alliance: Alliance!
}

type Pick implements Node {
  id: ID!
  competition(where: CompetitionWhereInput): Competition!
  team(where: TeamWhereInput): Team!
  grouping: String!
  rank: Int
  owner(where: ScoutTeamWhereInput): ScoutTeam!
}

type ScoutTeam implements Node {
  id: ID!
  affiliation(where: TeamWhereInput): Team
  teamFields(where: TeamFieldWhereInput, orderBy: TeamFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamField!]
  teamData(where: TeamDataWhereInput, orderBy: TeamDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamData!]
  matchFields(where: MatchFieldWhereInput, orderBy: MatchFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchField!]
  matchData(where: MatchDataWhereInput, orderBy: MatchDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchData!]
  members(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type User implements Node {
  id: ID!
  email: String!
  password: String!
  name: String!
  scoutTeam(where: ScoutTeamWhereInput): ScoutTeam
  roles: [Role!]
}


#
# Other Types
#

type AggregateBookmark {
  count: Int!
}

type AggregateCompetition {
  count: Int!
}

type AggregateGame {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateMatch {
  count: Int!
}

type AggregateMatchData {
  count: Int!
}

type AggregateMatchField {
  count: Int!
}

type AggregateMatchPlacement {
  count: Int!
}

type AggregatePick {
  count: Int!
}

type AggregateScoutTeam {
  count: Int!
}

type AggregateTBAUpdateRecord {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateTeamData {
  count: Int!
}

type AggregateTeamField {
  count: Int!
}

type AggregateUser {
  count: Int!
}

enum Alliance {
  RED
  BLUE
}

type BatchPayload {
  count: Long!
}

type BookmarkConnection {
  pageInfo: PageInfo!
  edges: [BookmarkEdge]!
  aggregate: AggregateBookmark!
}

input BookmarkCreateInput {
  grouping: String!
  submitter: UserCreateOneInput!
  team: TeamCreateOneInput!
}

type BookmarkEdge {
  node: Bookmark!
  cursor: String!
}

enum BookmarkOrderByInput {
  id_ASC
  id_DESC
  grouping_ASC
  grouping_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BookmarkPreviousValues {
  id: ID!
  grouping: String!
}

type BookmarkSubscriptionPayload {
  mutation: MutationType!
  node: Bookmark
  updatedFields: [String!]
  previousValues: BookmarkPreviousValues
}

input BookmarkSubscriptionWhereInput {
  AND: [BookmarkSubscriptionWhereInput!]
  OR: [BookmarkSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookmarkWhereInput
}

input BookmarkUpdateInput {
  grouping: String
  submitter: UserUpdateOneInput
  team: TeamUpdateOneInput
}

input BookmarkWhereInput {
  AND: [BookmarkWhereInput!]
  OR: [BookmarkWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  grouping: String
  grouping_not: String
  grouping_in: [String!]
  grouping_not_in: [String!]
  grouping_lt: String
  grouping_lte: String
  grouping_gt: String
  grouping_gte: String
  grouping_contains: String
  grouping_not_contains: String
  grouping_starts_with: String
  grouping_not_starts_with: String
  grouping_ends_with: String
  grouping_not_ends_with: String
  submitter: UserWhereInput
  team: TeamWhereInput
}

input BookmarkWhereUniqueInput {
  id: ID
}

type Competition {
  code: String!
  name: String
  startDate: DateTime
  endDate: DateTime
  location(where: LocationWhereInput): Location
  webpage: String
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team!]
}

type CompetitionConnection {
  pageInfo: PageInfo!
  edges: [CompetitionEdge]!
  aggregate: AggregateCompetition!
}

input CompetitionCreateInput {
  code: String!
  name: String
  startDate: DateTime
  endDate: DateTime
  webpage: String
  location: LocationCreateOneInput
  teams: TeamCreateManyWithoutCompetitionsInput
}

input CompetitionCreateManyWithoutTeamsInput {
  create: [CompetitionCreateWithoutTeamsInput!]
  connect: [CompetitionWhereUniqueInput!]
}

input CompetitionCreateOneInput {
  create: CompetitionCreateInput
  connect: CompetitionWhereUniqueInput
}

input CompetitionCreateWithoutTeamsInput {
  code: String!
  name: String
  startDate: DateTime
  endDate: DateTime
  webpage: String
  location: LocationCreateOneInput
}

type CompetitionEdge {
  node: Competition!
  cursor: String!
}

enum CompetitionOrderByInput {
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  webpage_ASC
  webpage_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CompetitionPreviousValues {
  code: String!
  name: String
  startDate: DateTime
  endDate: DateTime
  webpage: String
}

type CompetitionSubscriptionPayload {
  mutation: MutationType!
  node: Competition
  updatedFields: [String!]
  previousValues: CompetitionPreviousValues
}

input CompetitionSubscriptionWhereInput {
  AND: [CompetitionSubscriptionWhereInput!]
  OR: [CompetitionSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompetitionWhereInput
}

input CompetitionUpdateInput {
  code: String
  name: String
  startDate: DateTime
  endDate: DateTime
  webpage: String
  location: LocationUpdateOneInput
  teams: TeamUpdateManyWithoutCompetitionsInput
}

input CompetitionUpdateManyWithoutTeamsInput {
  create: [CompetitionCreateWithoutTeamsInput!]
  connect: [CompetitionWhereUniqueInput!]
  disconnect: [CompetitionWhereUniqueInput!]
  delete: [CompetitionWhereUniqueInput!]
  update: [CompetitionUpdateWithoutTeamsInput!]
  upsert: [CompetitionUpsertWithoutTeamsInput!]
}

input CompetitionUpdateOneInput {
  create: CompetitionCreateInput
  connect: CompetitionWhereUniqueInput
  disconnect: CompetitionWhereUniqueInput
  delete: CompetitionWhereUniqueInput
}

input CompetitionUpdateWithoutTeamsDataInput {
  code: String
  name: String
  startDate: DateTime
  endDate: DateTime
  webpage: String
  location: LocationUpdateOneInput
}

input CompetitionUpdateWithoutTeamsInput {
  where: CompetitionWhereUniqueInput!
  data: CompetitionUpdateWithoutTeamsDataInput!
}

input CompetitionUpsertWithoutTeamsInput {
  where: CompetitionWhereUniqueInput!
  update: CompetitionUpdateWithoutTeamsDataInput!
  create: CompetitionCreateWithoutTeamsInput!
}

input CompetitionWhereInput {
  AND: [CompetitionWhereInput!]
  OR: [CompetitionWhereInput!]
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  webpage: String
  webpage_not: String
  webpage_in: [String!]
  webpage_not_in: [String!]
  webpage_lt: String
  webpage_lte: String
  webpage_gt: String
  webpage_gte: String
  webpage_contains: String
  webpage_not_contains: String
  webpage_starts_with: String
  webpage_not_starts_with: String
  webpage_ends_with: String
  webpage_not_ends_with: String
  location: LocationWhereInput
  teams_every: TeamWhereInput
  teams_some: TeamWhereInput
  teams_none: TeamWhereInput
}

input CompetitionWhereUniqueInput {
  code: String
}

scalar DateTime

enum FieldType {
  NUMBER
  TEXT
  BOOLEAN
}

type Game {
  year: Int!
  name: String
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]!
  aggregate: AggregateGame!
}

input GameCreateInput {
  year: Int!
  name: String
}

type GameEdge {
  node: Game!
  cursor: String!
}

enum GameOrderByInput {
  year_ASC
  year_DESC
  name_ASC
  name_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type GamePreviousValues {
  year: Int!
  name: String
}

type GameSubscriptionPayload {
  mutation: MutationType!
  node: Game
  updatedFields: [String!]
  previousValues: GamePreviousValues
}

input GameSubscriptionWhereInput {
  AND: [GameSubscriptionWhereInput!]
  OR: [GameSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameWhereInput
}

input GameUpdateInput {
  year: Int
  name: String
}

input GameWhereInput {
  AND: [GameWhereInput!]
  OR: [GameWhereInput!]
  year: Int
  year_not: Int
  year_in: [Int!]
  year_not_in: [Int!]
  year_lt: Int
  year_lte: Int
  year_gt: Int
  year_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
}

input GameWhereUniqueInput {
  year: Int
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  path: String!
  name: String!
  private: Boolean
  submitter: UserCreateOneInput!
  owner: ScoutTeamCreateOneInput!
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  path_ASC
  path_DESC
  name_ASC
  name_DESC
  private_ASC
  private_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ImagePreviousValues {
  id: ID!
  path: String!
  name: String!
  private: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
}

input ImageUpdateInput {
  path: String
  name: String
  private: Boolean
  submitter: UserUpdateOneInput
  owner: ScoutTeamUpdateOneInput
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  private: Boolean
  private_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  submitter: UserWhereInput
  owner: ScoutTeamWhereInput
}

input ImageWhereUniqueInput {
  id: ID
}

type Location {
  address: String
  city: String
  state: String
  country: String
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  address: String
  city: String
  state: String
  country: String
}

input LocationCreateOneInput {
  create: LocationCreateInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  address_ASC
  address_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  country_ASC
  country_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type LocationPreviousValues {
  address: String
  city: String
  state: String
  country: String
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
}

input LocationUpdateInput {
  address: String
  city: String
  state: String
  country: String
}

input LocationUpdateOneInput {
  create: LocationCreateInput
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
}

scalar Long

type Match {
  name: String!
  teams(where: MatchPlacementWhereInput, orderBy: MatchPlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchPlacement!]
  matchData(where: MatchDataWhereInput, orderBy: MatchDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchData!]
}

type MatchConnection {
  pageInfo: PageInfo!
  edges: [MatchEdge]!
  aggregate: AggregateMatch!
}

input MatchCreateInput {
  name: String!
  teams: MatchPlacementCreateManyWithoutMatchInput
  matchData: MatchDataCreateManyWithoutMatchInput
}

input MatchCreateOneWithoutMatchDataInput {
  create: MatchCreateWithoutMatchDataInput
  connect: MatchWhereUniqueInput
}

input MatchCreateOneWithoutTeamsInput {
  create: MatchCreateWithoutTeamsInput
  connect: MatchWhereUniqueInput
}

input MatchCreateWithoutMatchDataInput {
  name: String!
  teams: MatchPlacementCreateManyWithoutMatchInput
}

input MatchCreateWithoutTeamsInput {
  name: String!
  matchData: MatchDataCreateManyWithoutMatchInput
}

type MatchDataConnection {
  pageInfo: PageInfo!
  edges: [MatchDataEdge]!
  aggregate: AggregateMatchData!
}

input MatchDataCreateInput {
  alliance: Alliance
  value: String!
  private: Boolean
  team: TeamCreateOneWithoutMatchDataInput
  match: MatchCreateOneWithoutMatchDataInput!
  field: MatchFieldCreateOneInput!
  owner: ScoutTeamCreateOneWithoutMatchDataInput!
  submitter: UserCreateOneInput!
}

input MatchDataCreateManyWithoutMatchInput {
  create: [MatchDataCreateWithoutMatchInput!]
  connect: [MatchDataWhereUniqueInput!]
}

input MatchDataCreateManyWithoutOwnerInput {
  create: [MatchDataCreateWithoutOwnerInput!]
  connect: [MatchDataWhereUniqueInput!]
}

input MatchDataCreateManyWithoutTeamInput {
  create: [MatchDataCreateWithoutTeamInput!]
  connect: [MatchDataWhereUniqueInput!]
}

input MatchDataCreateWithoutMatchInput {
  alliance: Alliance
  value: String!
  private: Boolean
  team: TeamCreateOneWithoutMatchDataInput
  field: MatchFieldCreateOneInput!
  owner: ScoutTeamCreateOneWithoutMatchDataInput!
  submitter: UserCreateOneInput!
}

input MatchDataCreateWithoutOwnerInput {
  alliance: Alliance
  value: String!
  private: Boolean
  team: TeamCreateOneWithoutMatchDataInput
  match: MatchCreateOneWithoutMatchDataInput!
  field: MatchFieldCreateOneInput!
  submitter: UserCreateOneInput!
}

input MatchDataCreateWithoutTeamInput {
  alliance: Alliance
  value: String!
  private: Boolean
  match: MatchCreateOneWithoutMatchDataInput!
  field: MatchFieldCreateOneInput!
  owner: ScoutTeamCreateOneWithoutMatchDataInput!
  submitter: UserCreateOneInput!
}

type MatchDataEdge {
  node: MatchData!
  cursor: String!
}

enum MatchDataOrderByInput {
  id_ASC
  id_DESC
  alliance_ASC
  alliance_DESC
  value_ASC
  value_DESC
  private_ASC
  private_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MatchDataPreviousValues {
  id: ID!
  alliance: Alliance
  value: String!
  private: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MatchDataSubscriptionPayload {
  mutation: MutationType!
  node: MatchData
  updatedFields: [String!]
  previousValues: MatchDataPreviousValues
}

input MatchDataSubscriptionWhereInput {
  AND: [MatchDataSubscriptionWhereInput!]
  OR: [MatchDataSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchDataWhereInput
}

input MatchDataUpdateInput {
  alliance: Alliance
  value: String
  private: Boolean
  team: TeamUpdateOneWithoutMatchDataInput
  match: MatchUpdateOneWithoutMatchDataInput
  field: MatchFieldUpdateOneInput
  owner: ScoutTeamUpdateOneWithoutMatchDataInput
  submitter: UserUpdateOneInput
}

input MatchDataUpdateManyWithoutMatchInput {
  create: [MatchDataCreateWithoutMatchInput!]
  connect: [MatchDataWhereUniqueInput!]
  disconnect: [MatchDataWhereUniqueInput!]
  delete: [MatchDataWhereUniqueInput!]
  update: [MatchDataUpdateWithoutMatchInput!]
  upsert: [MatchDataUpsertWithoutMatchInput!]
}

input MatchDataUpdateManyWithoutOwnerInput {
  create: [MatchDataCreateWithoutOwnerInput!]
  connect: [MatchDataWhereUniqueInput!]
  disconnect: [MatchDataWhereUniqueInput!]
  delete: [MatchDataWhereUniqueInput!]
  update: [MatchDataUpdateWithoutOwnerInput!]
  upsert: [MatchDataUpsertWithoutOwnerInput!]
}

input MatchDataUpdateManyWithoutTeamInput {
  create: [MatchDataCreateWithoutTeamInput!]
  connect: [MatchDataWhereUniqueInput!]
  disconnect: [MatchDataWhereUniqueInput!]
  delete: [MatchDataWhereUniqueInput!]
  update: [MatchDataUpdateWithoutTeamInput!]
  upsert: [MatchDataUpsertWithoutTeamInput!]
}

input MatchDataUpdateWithoutMatchDataInput {
  alliance: Alliance
  value: String
  private: Boolean
  team: TeamUpdateOneWithoutMatchDataInput
  field: MatchFieldUpdateOneInput
  owner: ScoutTeamUpdateOneWithoutMatchDataInput
  submitter: UserUpdateOneInput
}

input MatchDataUpdateWithoutMatchInput {
  where: MatchDataWhereUniqueInput!
  data: MatchDataUpdateWithoutMatchDataInput!
}

input MatchDataUpdateWithoutOwnerDataInput {
  alliance: Alliance
  value: String
  private: Boolean
  team: TeamUpdateOneWithoutMatchDataInput
  match: MatchUpdateOneWithoutMatchDataInput
  field: MatchFieldUpdateOneInput
  submitter: UserUpdateOneInput
}

input MatchDataUpdateWithoutOwnerInput {
  where: MatchDataWhereUniqueInput!
  data: MatchDataUpdateWithoutOwnerDataInput!
}

input MatchDataUpdateWithoutTeamDataInput {
  alliance: Alliance
  value: String
  private: Boolean
  match: MatchUpdateOneWithoutMatchDataInput
  field: MatchFieldUpdateOneInput
  owner: ScoutTeamUpdateOneWithoutMatchDataInput
  submitter: UserUpdateOneInput
}

input MatchDataUpdateWithoutTeamInput {
  where: MatchDataWhereUniqueInput!
  data: MatchDataUpdateWithoutTeamDataInput!
}

input MatchDataUpsertWithoutMatchInput {
  where: MatchDataWhereUniqueInput!
  update: MatchDataUpdateWithoutMatchDataInput!
  create: MatchDataCreateWithoutMatchInput!
}

input MatchDataUpsertWithoutOwnerInput {
  where: MatchDataWhereUniqueInput!
  update: MatchDataUpdateWithoutOwnerDataInput!
  create: MatchDataCreateWithoutOwnerInput!
}

input MatchDataUpsertWithoutTeamInput {
  where: MatchDataWhereUniqueInput!
  update: MatchDataUpdateWithoutTeamDataInput!
  create: MatchDataCreateWithoutTeamInput!
}

input MatchDataWhereInput {
  AND: [MatchDataWhereInput!]
  OR: [MatchDataWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  alliance: Alliance
  alliance_not: Alliance
  alliance_in: [Alliance!]
  alliance_not_in: [Alliance!]
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  private: Boolean
  private_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  team: TeamWhereInput
  match: MatchWhereInput
  field: MatchFieldWhereInput
  owner: ScoutTeamWhereInput
  submitter: UserWhereInput
}

input MatchDataWhereUniqueInput {
  id: ID
}

type MatchEdge {
  node: Match!
  cursor: String!
}

type MatchField {
  name: String!
  type: FieldType!
  private: Boolean
  submitter(where: UserWhereInput): User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MatchFieldConnection {
  pageInfo: PageInfo!
  edges: [MatchFieldEdge]!
  aggregate: AggregateMatchField!
}

input MatchFieldCreateInput {
  name: String!
  type: FieldType!
  private: Boolean
  submitter: UserCreateOneInput!
}

input MatchFieldCreateManyInput {
  create: [MatchFieldCreateInput!]
  connect: [MatchFieldWhereUniqueInput!]
}

input MatchFieldCreateOneInput {
  create: MatchFieldCreateInput
  connect: MatchFieldWhereUniqueInput
}

type MatchFieldEdge {
  node: MatchField!
  cursor: String!
}

enum MatchFieldOrderByInput {
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  private_ASC
  private_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  id_ASC
  id_DESC
}

type MatchFieldPreviousValues {
  name: String!
  type: FieldType!
  private: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MatchFieldSubscriptionPayload {
  mutation: MutationType!
  node: MatchField
  updatedFields: [String!]
  previousValues: MatchFieldPreviousValues
}

input MatchFieldSubscriptionWhereInput {
  AND: [MatchFieldSubscriptionWhereInput!]
  OR: [MatchFieldSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchFieldWhereInput
}

input MatchFieldUpdateInput {
  name: String
  type: FieldType
  private: Boolean
  submitter: UserUpdateOneInput
}

input MatchFieldUpdateManyInput {
  create: [MatchFieldCreateInput!]
  connect: [MatchFieldWhereUniqueInput!]
  disconnect: [MatchFieldWhereUniqueInput!]
  delete: [MatchFieldWhereUniqueInput!]
}

input MatchFieldUpdateOneInput {
  create: MatchFieldCreateInput
  connect: MatchFieldWhereUniqueInput
  disconnect: MatchFieldWhereUniqueInput
  delete: MatchFieldWhereUniqueInput
}

input MatchFieldWhereInput {
  AND: [MatchFieldWhereInput!]
  OR: [MatchFieldWhereInput!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: FieldType
  type_not: FieldType
  type_in: [FieldType!]
  type_not_in: [FieldType!]
  private: Boolean
  private_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  submitter: UserWhereInput
}

input MatchFieldWhereUniqueInput {
  name: String
}

enum MatchOrderByInput {
  name_ASC
  name_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MatchPlacementConnection {
  pageInfo: PageInfo!
  edges: [MatchPlacementEdge]!
  aggregate: AggregateMatchPlacement!
}

input MatchPlacementCreateInput {
  alliance: Alliance!
  match: MatchCreateOneWithoutTeamsInput!
  team: TeamCreateOneWithoutMatchesInput!
}

input MatchPlacementCreateManyWithoutMatchInput {
  create: [MatchPlacementCreateWithoutMatchInput!]
  connect: [MatchPlacementWhereUniqueInput!]
}

input MatchPlacementCreateManyWithoutTeamInput {
  create: [MatchPlacementCreateWithoutTeamInput!]
  connect: [MatchPlacementWhereUniqueInput!]
}

input MatchPlacementCreateWithoutMatchInput {
  alliance: Alliance!
  team: TeamCreateOneWithoutMatchesInput!
}

input MatchPlacementCreateWithoutTeamInput {
  alliance: Alliance!
  match: MatchCreateOneWithoutTeamsInput!
}

type MatchPlacementEdge {
  node: MatchPlacement!
  cursor: String!
}

enum MatchPlacementOrderByInput {
  id_ASC
  id_DESC
  alliance_ASC
  alliance_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MatchPlacementPreviousValues {
  id: ID!
  alliance: Alliance!
}

type MatchPlacementSubscriptionPayload {
  mutation: MutationType!
  node: MatchPlacement
  updatedFields: [String!]
  previousValues: MatchPlacementPreviousValues
}

input MatchPlacementSubscriptionWhereInput {
  AND: [MatchPlacementSubscriptionWhereInput!]
  OR: [MatchPlacementSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchPlacementWhereInput
}

input MatchPlacementUpdateInput {
  alliance: Alliance
  match: MatchUpdateOneWithoutTeamsInput
  team: TeamUpdateOneWithoutMatchesInput
}

input MatchPlacementUpdateManyWithoutMatchInput {
  create: [MatchPlacementCreateWithoutMatchInput!]
  connect: [MatchPlacementWhereUniqueInput!]
  disconnect: [MatchPlacementWhereUniqueInput!]
  delete: [MatchPlacementWhereUniqueInput!]
  update: [MatchPlacementUpdateWithoutMatchInput!]
  upsert: [MatchPlacementUpsertWithoutMatchInput!]
}

input MatchPlacementUpdateManyWithoutTeamInput {
  create: [MatchPlacementCreateWithoutTeamInput!]
  connect: [MatchPlacementWhereUniqueInput!]
  disconnect: [MatchPlacementWhereUniqueInput!]
  delete: [MatchPlacementWhereUniqueInput!]
  update: [MatchPlacementUpdateWithoutTeamInput!]
  upsert: [MatchPlacementUpsertWithoutTeamInput!]
}

input MatchPlacementUpdateWithoutMatchDataInput {
  alliance: Alliance
  team: TeamUpdateOneWithoutMatchesInput
}

input MatchPlacementUpdateWithoutMatchInput {
  where: MatchPlacementWhereUniqueInput!
  data: MatchPlacementUpdateWithoutMatchDataInput!
}

input MatchPlacementUpdateWithoutTeamDataInput {
  alliance: Alliance
  match: MatchUpdateOneWithoutTeamsInput
}

input MatchPlacementUpdateWithoutTeamInput {
  where: MatchPlacementWhereUniqueInput!
  data: MatchPlacementUpdateWithoutTeamDataInput!
}

input MatchPlacementUpsertWithoutMatchInput {
  where: MatchPlacementWhereUniqueInput!
  update: MatchPlacementUpdateWithoutMatchDataInput!
  create: MatchPlacementCreateWithoutMatchInput!
}

input MatchPlacementUpsertWithoutTeamInput {
  where: MatchPlacementWhereUniqueInput!
  update: MatchPlacementUpdateWithoutTeamDataInput!
  create: MatchPlacementCreateWithoutTeamInput!
}

input MatchPlacementWhereInput {
  AND: [MatchPlacementWhereInput!]
  OR: [MatchPlacementWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  alliance: Alliance
  alliance_not: Alliance
  alliance_in: [Alliance!]
  alliance_not_in: [Alliance!]
  match: MatchWhereInput
  team: TeamWhereInput
}

input MatchPlacementWhereUniqueInput {
  id: ID
}

type MatchPreviousValues {
  name: String!
}

type MatchSubscriptionPayload {
  mutation: MutationType!
  node: Match
  updatedFields: [String!]
  previousValues: MatchPreviousValues
}

input MatchSubscriptionWhereInput {
  AND: [MatchSubscriptionWhereInput!]
  OR: [MatchSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MatchWhereInput
}

input MatchUpdateInput {
  name: String
  teams: MatchPlacementUpdateManyWithoutMatchInput
  matchData: MatchDataUpdateManyWithoutMatchInput
}

input MatchUpdateOneWithoutMatchDataInput {
  create: MatchCreateWithoutMatchDataInput
  connect: MatchWhereUniqueInput
  disconnect: MatchWhereUniqueInput
  delete: MatchWhereUniqueInput
  update: MatchUpdateWithoutMatchDataInput
  upsert: MatchUpsertWithoutMatchDataInput
}

input MatchUpdateOneWithoutTeamsInput {
  create: MatchCreateWithoutTeamsInput
  connect: MatchWhereUniqueInput
  disconnect: MatchWhereUniqueInput
  delete: MatchWhereUniqueInput
  update: MatchUpdateWithoutTeamsInput
  upsert: MatchUpsertWithoutTeamsInput
}

input MatchUpdateWithoutMatchDataDataInput {
  name: String
  teams: MatchPlacementUpdateManyWithoutMatchInput
}

input MatchUpdateWithoutMatchDataInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateWithoutMatchDataDataInput!
}

input MatchUpdateWithoutTeamsDataInput {
  name: String
  matchData: MatchDataUpdateManyWithoutMatchInput
}

input MatchUpdateWithoutTeamsInput {
  where: MatchWhereUniqueInput!
  data: MatchUpdateWithoutTeamsDataInput!
}

input MatchUpsertWithoutMatchDataInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateWithoutMatchDataDataInput!
  create: MatchCreateWithoutMatchDataInput!
}

input MatchUpsertWithoutTeamsInput {
  where: MatchWhereUniqueInput!
  update: MatchUpdateWithoutTeamsDataInput!
  create: MatchCreateWithoutTeamsInput!
}

input MatchWhereInput {
  AND: [MatchWhereInput!]
  OR: [MatchWhereInput!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  teams_every: MatchPlacementWhereInput
  teams_some: MatchPlacementWhereInput
  teams_none: MatchPlacementWhereInput
  matchData_every: MatchDataWhereInput
  matchData_some: MatchDataWhereInput
  matchData_none: MatchDataWhereInput
}

input MatchWhereUniqueInput {
  name: String
}

type Mutation {
  createLocation(data: LocationCreateInput!): Location!
  createTBAUpdateRecord(data: TBAUpdateRecordCreateInput!): TBAUpdateRecord!
  createUser(data: UserCreateInput!): User!
  createScoutTeam(data: ScoutTeamCreateInput!): ScoutTeam!
  createBookmark(data: BookmarkCreateInput!): Bookmark!
  createImage(data: ImageCreateInput!): Image!
  createPick(data: PickCreateInput!): Pick!
  createTeamField(data: TeamFieldCreateInput!): TeamField!
  createTeamData(data: TeamDataCreateInput!): TeamData!
  createTeam(data: TeamCreateInput!): Team!
  createGame(data: GameCreateInput!): Game!
  createCompetition(data: CompetitionCreateInput!): Competition!
  createMatchField(data: MatchFieldCreateInput!): MatchField!
  createMatchData(data: MatchDataCreateInput!): MatchData!
  createMatchPlacement(data: MatchPlacementCreateInput!): MatchPlacement!
  createMatch(data: MatchCreateInput!): Match!
  updateTBAUpdateRecord(data: TBAUpdateRecordUpdateInput!, where: TBAUpdateRecordWhereUniqueInput!): TBAUpdateRecord
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateScoutTeam(data: ScoutTeamUpdateInput!, where: ScoutTeamWhereUniqueInput!): ScoutTeam
  updateBookmark(data: BookmarkUpdateInput!, where: BookmarkWhereUniqueInput!): Bookmark
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updatePick(data: PickUpdateInput!, where: PickWhereUniqueInput!): Pick
  updateTeamField(data: TeamFieldUpdateInput!, where: TeamFieldWhereUniqueInput!): TeamField
  updateTeamData(data: TeamDataUpdateInput!, where: TeamDataWhereUniqueInput!): TeamData
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateCompetition(data: CompetitionUpdateInput!, where: CompetitionWhereUniqueInput!): Competition
  updateMatchField(data: MatchFieldUpdateInput!, where: MatchFieldWhereUniqueInput!): MatchField
  updateMatchData(data: MatchDataUpdateInput!, where: MatchDataWhereUniqueInput!): MatchData
  updateMatchPlacement(data: MatchPlacementUpdateInput!, where: MatchPlacementWhereUniqueInput!): MatchPlacement
  updateMatch(data: MatchUpdateInput!, where: MatchWhereUniqueInput!): Match
  deleteTBAUpdateRecord(where: TBAUpdateRecordWhereUniqueInput!): TBAUpdateRecord
  deleteUser(where: UserWhereUniqueInput!): User
  deleteScoutTeam(where: ScoutTeamWhereUniqueInput!): ScoutTeam
  deleteBookmark(where: BookmarkWhereUniqueInput!): Bookmark
  deleteImage(where: ImageWhereUniqueInput!): Image
  deletePick(where: PickWhereUniqueInput!): Pick
  deleteTeamField(where: TeamFieldWhereUniqueInput!): TeamField
  deleteTeamData(where: TeamDataWhereUniqueInput!): TeamData
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteCompetition(where: CompetitionWhereUniqueInput!): Competition
  deleteMatchField(where: MatchFieldWhereUniqueInput!): MatchField
  deleteMatchData(where: MatchDataWhereUniqueInput!): MatchData
  deleteMatchPlacement(where: MatchPlacementWhereUniqueInput!): MatchPlacement
  deleteMatch(where: MatchWhereUniqueInput!): Match
  upsertTBAUpdateRecord(where: TBAUpdateRecordWhereUniqueInput!, create: TBAUpdateRecordCreateInput!, update: TBAUpdateRecordUpdateInput!): TBAUpdateRecord!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertScoutTeam(where: ScoutTeamWhereUniqueInput!, create: ScoutTeamCreateInput!, update: ScoutTeamUpdateInput!): ScoutTeam!
  upsertBookmark(where: BookmarkWhereUniqueInput!, create: BookmarkCreateInput!, update: BookmarkUpdateInput!): Bookmark!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  upsertPick(where: PickWhereUniqueInput!, create: PickCreateInput!, update: PickUpdateInput!): Pick!
  upsertTeamField(where: TeamFieldWhereUniqueInput!, create: TeamFieldCreateInput!, update: TeamFieldUpdateInput!): TeamField!
  upsertTeamData(where: TeamDataWhereUniqueInput!, create: TeamDataCreateInput!, update: TeamDataUpdateInput!): TeamData!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  upsertGame(where: GameWhereUniqueInput!, create: GameCreateInput!, update: GameUpdateInput!): Game!
  upsertCompetition(where: CompetitionWhereUniqueInput!, create: CompetitionCreateInput!, update: CompetitionUpdateInput!): Competition!
  upsertMatchField(where: MatchFieldWhereUniqueInput!, create: MatchFieldCreateInput!, update: MatchFieldUpdateInput!): MatchField!
  upsertMatchData(where: MatchDataWhereUniqueInput!, create: MatchDataCreateInput!, update: MatchDataUpdateInput!): MatchData!
  upsertMatchPlacement(where: MatchPlacementWhereUniqueInput!, create: MatchPlacementCreateInput!, update: MatchPlacementUpdateInput!): MatchPlacement!
  upsertMatch(where: MatchWhereUniqueInput!, create: MatchCreateInput!, update: MatchUpdateInput!): Match!
  updateManyLocations(data: LocationUpdateInput!, where: LocationWhereInput!): BatchPayload!
  updateManyTBAUpdateRecords(data: TBAUpdateRecordUpdateInput!, where: TBAUpdateRecordWhereInput!): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload!
  updateManyScoutTeams(data: ScoutTeamUpdateInput!, where: ScoutTeamWhereInput!): BatchPayload!
  updateManyBookmarks(data: BookmarkUpdateInput!, where: BookmarkWhereInput!): BatchPayload!
  updateManyImages(data: ImageUpdateInput!, where: ImageWhereInput!): BatchPayload!
  updateManyPicks(data: PickUpdateInput!, where: PickWhereInput!): BatchPayload!
  updateManyTeamFields(data: TeamFieldUpdateInput!, where: TeamFieldWhereInput!): BatchPayload!
  updateManyTeamDatas(data: TeamDataUpdateInput!, where: TeamDataWhereInput!): BatchPayload!
  updateManyTeams(data: TeamUpdateInput!, where: TeamWhereInput!): BatchPayload!
  updateManyGames(data: GameUpdateInput!, where: GameWhereInput!): BatchPayload!
  updateManyCompetitions(data: CompetitionUpdateInput!, where: CompetitionWhereInput!): BatchPayload!
  updateManyMatchFields(data: MatchFieldUpdateInput!, where: MatchFieldWhereInput!): BatchPayload!
  updateManyMatchDatas(data: MatchDataUpdateInput!, where: MatchDataWhereInput!): BatchPayload!
  updateManyMatchPlacements(data: MatchPlacementUpdateInput!, where: MatchPlacementWhereInput!): BatchPayload!
  updateManyMatches(data: MatchUpdateInput!, where: MatchWhereInput!): BatchPayload!
  deleteManyLocations(where: LocationWhereInput!): BatchPayload!
  deleteManyTBAUpdateRecords(where: TBAUpdateRecordWhereInput!): BatchPayload!
  deleteManyUsers(where: UserWhereInput!): BatchPayload!
  deleteManyScoutTeams(where: ScoutTeamWhereInput!): BatchPayload!
  deleteManyBookmarks(where: BookmarkWhereInput!): BatchPayload!
  deleteManyImages(where: ImageWhereInput!): BatchPayload!
  deleteManyPicks(where: PickWhereInput!): BatchPayload!
  deleteManyTeamFields(where: TeamFieldWhereInput!): BatchPayload!
  deleteManyTeamDatas(where: TeamDataWhereInput!): BatchPayload!
  deleteManyTeams(where: TeamWhereInput!): BatchPayload!
  deleteManyGames(where: GameWhereInput!): BatchPayload!
  deleteManyCompetitions(where: CompetitionWhereInput!): BatchPayload!
  deleteManyMatchFields(where: MatchFieldWhereInput!): BatchPayload!
  deleteManyMatchDatas(where: MatchDataWhereInput!): BatchPayload!
  deleteManyMatchPlacements(where: MatchPlacementWhereInput!): BatchPayload!
  deleteManyMatches(where: MatchWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PickConnection {
  pageInfo: PageInfo!
  edges: [PickEdge]!
  aggregate: AggregatePick!
}

input PickCreateInput {
  grouping: String!
  rank: Int
  competition: CompetitionCreateOneInput!
  team: TeamCreateOneInput!
  owner: ScoutTeamCreateOneInput!
}

type PickEdge {
  node: Pick!
  cursor: String!
}

enum PickOrderByInput {
  id_ASC
  id_DESC
  grouping_ASC
  grouping_DESC
  rank_ASC
  rank_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PickPreviousValues {
  id: ID!
  grouping: String!
  rank: Int
}

type PickSubscriptionPayload {
  mutation: MutationType!
  node: Pick
  updatedFields: [String!]
  previousValues: PickPreviousValues
}

input PickSubscriptionWhereInput {
  AND: [PickSubscriptionWhereInput!]
  OR: [PickSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PickWhereInput
}

input PickUpdateInput {
  grouping: String
  rank: Int
  competition: CompetitionUpdateOneInput
  team: TeamUpdateOneInput
  owner: ScoutTeamUpdateOneInput
}

input PickWhereInput {
  AND: [PickWhereInput!]
  OR: [PickWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  grouping: String
  grouping_not: String
  grouping_in: [String!]
  grouping_not_in: [String!]
  grouping_lt: String
  grouping_lte: String
  grouping_gt: String
  grouping_gte: String
  grouping_contains: String
  grouping_not_contains: String
  grouping_starts_with: String
  grouping_not_starts_with: String
  grouping_ends_with: String
  grouping_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  competition: CompetitionWhereInput
  team: TeamWhereInput
  owner: ScoutTeamWhereInput
}

input PickWhereUniqueInput {
  id: ID
}

type Query {
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  tBAUpdateRecords(where: TBAUpdateRecordWhereInput, orderBy: TBAUpdateRecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TBAUpdateRecord]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  scoutTeams(where: ScoutTeamWhereInput, orderBy: ScoutTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ScoutTeam]!
  bookmarks(where: BookmarkWhereInput, orderBy: BookmarkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bookmark]!
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  picks(where: PickWhereInput, orderBy: PickOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pick]!
  teamFields(where: TeamFieldWhereInput, orderBy: TeamFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamField]!
  teamDatas(where: TeamDataWhereInput, orderBy: TeamDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamData]!
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game]!
  competitions(where: CompetitionWhereInput, orderBy: CompetitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Competition]!
  matchFields(where: MatchFieldWhereInput, orderBy: MatchFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchField]!
  matchDatas(where: MatchDataWhereInput, orderBy: MatchDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchData]!
  matchPlacements(where: MatchPlacementWhereInput, orderBy: MatchPlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchPlacement]!
  matches(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Match]!
  tBAUpdateRecord(where: TBAUpdateRecordWhereUniqueInput!): TBAUpdateRecord
  user(where: UserWhereUniqueInput!): User
  scoutTeam(where: ScoutTeamWhereUniqueInput!): ScoutTeam
  bookmark(where: BookmarkWhereUniqueInput!): Bookmark
  image(where: ImageWhereUniqueInput!): Image
  pick(where: PickWhereUniqueInput!): Pick
  teamField(where: TeamFieldWhereUniqueInput!): TeamField
  teamData(where: TeamDataWhereUniqueInput!): TeamData
  team(where: TeamWhereUniqueInput!): Team
  game(where: GameWhereUniqueInput!): Game
  competition(where: CompetitionWhereUniqueInput!): Competition
  matchField(where: MatchFieldWhereUniqueInput!): MatchField
  matchData(where: MatchDataWhereUniqueInput!): MatchData
  matchPlacement(where: MatchPlacementWhereUniqueInput!): MatchPlacement
  match(where: MatchWhereUniqueInput!): Match
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  tBAUpdateRecordsConnection(where: TBAUpdateRecordWhereInput, orderBy: TBAUpdateRecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TBAUpdateRecordConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  scoutTeamsConnection(where: ScoutTeamWhereInput, orderBy: ScoutTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoutTeamConnection!
  bookmarksConnection(where: BookmarkWhereInput, orderBy: BookmarkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookmarkConnection!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  picksConnection(where: PickWhereInput, orderBy: PickOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PickConnection!
  teamFieldsConnection(where: TeamFieldWhereInput, orderBy: TeamFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamFieldConnection!
  teamDatasConnection(where: TeamDataWhereInput, orderBy: TeamDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamDataConnection!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  gamesConnection(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameConnection!
  competitionsConnection(where: CompetitionWhereInput, orderBy: CompetitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompetitionConnection!
  matchFieldsConnection(where: MatchFieldWhereInput, orderBy: MatchFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchFieldConnection!
  matchDatasConnection(where: MatchDataWhereInput, orderBy: MatchDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchDataConnection!
  matchPlacementsConnection(where: MatchPlacementWhereInput, orderBy: MatchPlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchPlacementConnection!
  matchesConnection(where: MatchWhereInput, orderBy: MatchOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MatchConnection!
  node(id: ID!): Node
}

enum Role {
  SCOUTMASTER
  DRIVE_TEAM
  ANALYST
  DATA_ENTRY
  PIT_SCOUT
  MATCH_SCOUT
  TEAM_MEMBER
}

type ScoutTeamConnection {
  pageInfo: PageInfo!
  edges: [ScoutTeamEdge]!
  aggregate: AggregateScoutTeam!
}

input ScoutTeamCreateInput {
  affiliation: TeamCreateOneInput
  teamFields: TeamFieldCreateManyInput
  teamData: TeamDataCreateManyWithoutOwnerInput
  matchFields: MatchFieldCreateManyInput
  matchData: MatchDataCreateManyWithoutOwnerInput
  members: UserCreateManyWithoutScoutTeamInput
}

input ScoutTeamCreateOneInput {
  create: ScoutTeamCreateInput
  connect: ScoutTeamWhereUniqueInput
}

input ScoutTeamCreateOneWithoutMatchDataInput {
  create: ScoutTeamCreateWithoutMatchDataInput
  connect: ScoutTeamWhereUniqueInput
}

input ScoutTeamCreateOneWithoutMembersInput {
  create: ScoutTeamCreateWithoutMembersInput
  connect: ScoutTeamWhereUniqueInput
}

input ScoutTeamCreateOneWithoutTeamDataInput {
  create: ScoutTeamCreateWithoutTeamDataInput
  connect: ScoutTeamWhereUniqueInput
}

input ScoutTeamCreateWithoutMatchDataInput {
  affiliation: TeamCreateOneInput
  teamFields: TeamFieldCreateManyInput
  teamData: TeamDataCreateManyWithoutOwnerInput
  matchFields: MatchFieldCreateManyInput
  members: UserCreateManyWithoutScoutTeamInput
}

input ScoutTeamCreateWithoutMembersInput {
  affiliation: TeamCreateOneInput
  teamFields: TeamFieldCreateManyInput
  teamData: TeamDataCreateManyWithoutOwnerInput
  matchFields: MatchFieldCreateManyInput
  matchData: MatchDataCreateManyWithoutOwnerInput
}

input ScoutTeamCreateWithoutTeamDataInput {
  affiliation: TeamCreateOneInput
  teamFields: TeamFieldCreateManyInput
  matchFields: MatchFieldCreateManyInput
  matchData: MatchDataCreateManyWithoutOwnerInput
  members: UserCreateManyWithoutScoutTeamInput
}

type ScoutTeamEdge {
  node: ScoutTeam!
  cursor: String!
}

enum ScoutTeamOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type ScoutTeamPreviousValues {
  id: ID!
}

type ScoutTeamSubscriptionPayload {
  mutation: MutationType!
  node: ScoutTeam
  updatedFields: [String!]
  previousValues: ScoutTeamPreviousValues
}

input ScoutTeamSubscriptionWhereInput {
  AND: [ScoutTeamSubscriptionWhereInput!]
  OR: [ScoutTeamSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoutTeamWhereInput
}

input ScoutTeamUpdateInput {
  affiliation: TeamUpdateOneInput
  teamFields: TeamFieldUpdateManyInput
  teamData: TeamDataUpdateManyWithoutOwnerInput
  matchFields: MatchFieldUpdateManyInput
  matchData: MatchDataUpdateManyWithoutOwnerInput
  members: UserUpdateManyWithoutScoutTeamInput
}

input ScoutTeamUpdateOneInput {
  create: ScoutTeamCreateInput
  connect: ScoutTeamWhereUniqueInput
  disconnect: ScoutTeamWhereUniqueInput
  delete: ScoutTeamWhereUniqueInput
}

input ScoutTeamUpdateOneWithoutMatchDataInput {
  create: ScoutTeamCreateWithoutMatchDataInput
  connect: ScoutTeamWhereUniqueInput
  disconnect: ScoutTeamWhereUniqueInput
  delete: ScoutTeamWhereUniqueInput
  update: ScoutTeamUpdateWithoutMatchDataInput
  upsert: ScoutTeamUpsertWithoutMatchDataInput
}

input ScoutTeamUpdateOneWithoutMembersInput {
  create: ScoutTeamCreateWithoutMembersInput
  connect: ScoutTeamWhereUniqueInput
  disconnect: ScoutTeamWhereUniqueInput
  delete: ScoutTeamWhereUniqueInput
  update: ScoutTeamUpdateWithoutMembersInput
  upsert: ScoutTeamUpsertWithoutMembersInput
}

input ScoutTeamUpdateOneWithoutTeamDataInput {
  create: ScoutTeamCreateWithoutTeamDataInput
  connect: ScoutTeamWhereUniqueInput
  disconnect: ScoutTeamWhereUniqueInput
  delete: ScoutTeamWhereUniqueInput
  update: ScoutTeamUpdateWithoutTeamDataInput
  upsert: ScoutTeamUpsertWithoutTeamDataInput
}

input ScoutTeamUpdateWithoutMatchDataDataInput {
  affiliation: TeamUpdateOneInput
  teamFields: TeamFieldUpdateManyInput
  teamData: TeamDataUpdateManyWithoutOwnerInput
  matchFields: MatchFieldUpdateManyInput
  members: UserUpdateManyWithoutScoutTeamInput
}

input ScoutTeamUpdateWithoutMatchDataInput {
  where: ScoutTeamWhereUniqueInput!
  data: ScoutTeamUpdateWithoutMatchDataDataInput!
}

input ScoutTeamUpdateWithoutMembersDataInput {
  affiliation: TeamUpdateOneInput
  teamFields: TeamFieldUpdateManyInput
  teamData: TeamDataUpdateManyWithoutOwnerInput
  matchFields: MatchFieldUpdateManyInput
  matchData: MatchDataUpdateManyWithoutOwnerInput
}

input ScoutTeamUpdateWithoutMembersInput {
  where: ScoutTeamWhereUniqueInput!
  data: ScoutTeamUpdateWithoutMembersDataInput!
}

input ScoutTeamUpdateWithoutTeamDataDataInput {
  affiliation: TeamUpdateOneInput
  teamFields: TeamFieldUpdateManyInput
  matchFields: MatchFieldUpdateManyInput
  matchData: MatchDataUpdateManyWithoutOwnerInput
  members: UserUpdateManyWithoutScoutTeamInput
}

input ScoutTeamUpdateWithoutTeamDataInput {
  where: ScoutTeamWhereUniqueInput!
  data: ScoutTeamUpdateWithoutTeamDataDataInput!
}

input ScoutTeamUpsertWithoutMatchDataInput {
  where: ScoutTeamWhereUniqueInput!
  update: ScoutTeamUpdateWithoutMatchDataDataInput!
  create: ScoutTeamCreateWithoutMatchDataInput!
}

input ScoutTeamUpsertWithoutMembersInput {
  where: ScoutTeamWhereUniqueInput!
  update: ScoutTeamUpdateWithoutMembersDataInput!
  create: ScoutTeamCreateWithoutMembersInput!
}

input ScoutTeamUpsertWithoutTeamDataInput {
  where: ScoutTeamWhereUniqueInput!
  update: ScoutTeamUpdateWithoutTeamDataDataInput!
  create: ScoutTeamCreateWithoutTeamDataInput!
}

input ScoutTeamWhereInput {
  AND: [ScoutTeamWhereInput!]
  OR: [ScoutTeamWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  affiliation: TeamWhereInput
  teamFields_every: TeamFieldWhereInput
  teamFields_some: TeamFieldWhereInput
  teamFields_none: TeamFieldWhereInput
  teamData_every: TeamDataWhereInput
  teamData_some: TeamDataWhereInput
  teamData_none: TeamDataWhereInput
  matchFields_every: MatchFieldWhereInput
  matchFields_some: MatchFieldWhereInput
  matchFields_none: MatchFieldWhereInput
  matchData_every: MatchDataWhereInput
  matchData_some: MatchDataWhereInput
  matchData_none: MatchDataWhereInput
  members_every: UserWhereInput
  members_some: UserWhereInput
  members_none: UserWhereInput
}

input ScoutTeamWhereUniqueInput {
  id: ID
}

type Subscription {
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  tBAUpdateRecord(where: TBAUpdateRecordSubscriptionWhereInput): TBAUpdateRecordSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  scoutTeam(where: ScoutTeamSubscriptionWhereInput): ScoutTeamSubscriptionPayload
  bookmark(where: BookmarkSubscriptionWhereInput): BookmarkSubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  pick(where: PickSubscriptionWhereInput): PickSubscriptionPayload
  teamField(where: TeamFieldSubscriptionWhereInput): TeamFieldSubscriptionPayload
  teamData(where: TeamDataSubscriptionWhereInput): TeamDataSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  game(where: GameSubscriptionWhereInput): GameSubscriptionPayload
  competition(where: CompetitionSubscriptionWhereInput): CompetitionSubscriptionPayload
  matchField(where: MatchFieldSubscriptionWhereInput): MatchFieldSubscriptionPayload
  matchData(where: MatchDataSubscriptionWhereInput): MatchDataSubscriptionPayload
  matchPlacement(where: MatchPlacementSubscriptionWhereInput): MatchPlacementSubscriptionPayload
  match(where: MatchSubscriptionWhereInput): MatchSubscriptionPayload
}

type TBAUpdateRecord {
  endpoint: String!
  lastResponse: String
  lastModified: String!
}

type TBAUpdateRecordConnection {
  pageInfo: PageInfo!
  edges: [TBAUpdateRecordEdge]!
  aggregate: AggregateTBAUpdateRecord!
}

input TBAUpdateRecordCreateInput {
  endpoint: String!
  lastResponse: String
  lastModified: String!
}

type TBAUpdateRecordEdge {
  node: TBAUpdateRecord!
  cursor: String!
}

enum TBAUpdateRecordOrderByInput {
  endpoint_ASC
  endpoint_DESC
  lastResponse_ASC
  lastResponse_DESC
  lastModified_ASC
  lastModified_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TBAUpdateRecordPreviousValues {
  endpoint: String!
  lastResponse: String
  lastModified: String!
}

type TBAUpdateRecordSubscriptionPayload {
  mutation: MutationType!
  node: TBAUpdateRecord
  updatedFields: [String!]
  previousValues: TBAUpdateRecordPreviousValues
}

input TBAUpdateRecordSubscriptionWhereInput {
  AND: [TBAUpdateRecordSubscriptionWhereInput!]
  OR: [TBAUpdateRecordSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TBAUpdateRecordWhereInput
}

input TBAUpdateRecordUpdateInput {
  endpoint: String
  lastResponse: String
  lastModified: String
}

input TBAUpdateRecordWhereInput {
  AND: [TBAUpdateRecordWhereInput!]
  OR: [TBAUpdateRecordWhereInput!]
  endpoint: String
  endpoint_not: String
  endpoint_in: [String!]
  endpoint_not_in: [String!]
  endpoint_lt: String
  endpoint_lte: String
  endpoint_gt: String
  endpoint_gte: String
  endpoint_contains: String
  endpoint_not_contains: String
  endpoint_starts_with: String
  endpoint_not_starts_with: String
  endpoint_ends_with: String
  endpoint_not_ends_with: String
  lastResponse: String
  lastResponse_not: String
  lastResponse_in: [String!]
  lastResponse_not_in: [String!]
  lastResponse_lt: String
  lastResponse_lte: String
  lastResponse_gt: String
  lastResponse_gte: String
  lastResponse_contains: String
  lastResponse_not_contains: String
  lastResponse_starts_with: String
  lastResponse_not_starts_with: String
  lastResponse_ends_with: String
  lastResponse_not_ends_with: String
  lastModified: String
  lastModified_not: String
  lastModified_in: [String!]
  lastModified_not_in: [String!]
  lastModified_lt: String
  lastModified_lte: String
  lastModified_gt: String
  lastModified_gte: String
  lastModified_contains: String
  lastModified_not_contains: String
  lastModified_starts_with: String
  lastModified_not_starts_with: String
  lastModified_ends_with: String
  lastModified_not_ends_with: String
}

input TBAUpdateRecordWhereUniqueInput {
  endpoint: String
}

type Team {
  number: Int!
  competitions(where: CompetitionWhereInput, orderBy: CompetitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Competition!]
  matches(where: MatchPlacementWhereInput, orderBy: MatchPlacementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchPlacement!]
  teamData(where: TeamDataWhereInput, orderBy: TeamDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamData!]
  matchData(where: MatchDataWhereInput, orderBy: MatchDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MatchData!]
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  number: Int!
  competitions: CompetitionCreateManyWithoutTeamsInput
  matches: MatchPlacementCreateManyWithoutTeamInput
  teamData: TeamDataCreateManyInput
  matchData: MatchDataCreateManyWithoutTeamInput
}

input TeamCreateManyWithoutCompetitionsInput {
  create: [TeamCreateWithoutCompetitionsInput!]
  connect: [TeamWhereUniqueInput!]
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutMatchDataInput {
  create: TeamCreateWithoutMatchDataInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutMatchesInput {
  create: TeamCreateWithoutMatchesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutCompetitionsInput {
  number: Int!
  matches: MatchPlacementCreateManyWithoutTeamInput
  teamData: TeamDataCreateManyInput
  matchData: MatchDataCreateManyWithoutTeamInput
}

input TeamCreateWithoutMatchDataInput {
  number: Int!
  competitions: CompetitionCreateManyWithoutTeamsInput
  matches: MatchPlacementCreateManyWithoutTeamInput
  teamData: TeamDataCreateManyInput
}

input TeamCreateWithoutMatchesInput {
  number: Int!
  competitions: CompetitionCreateManyWithoutTeamsInput
  teamData: TeamDataCreateManyInput
  matchData: MatchDataCreateManyWithoutTeamInput
}

type TeamData {
  name: String!
  value: String!
  owner(where: ScoutTeamWhereInput): ScoutTeam
  private: Boolean
  submitter(where: UserWhereInput): User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamDataConnection {
  pageInfo: PageInfo!
  edges: [TeamDataEdge]!
  aggregate: AggregateTeamData!
}

input TeamDataCreateInput {
  name: String!
  value: String!
  private: Boolean
  owner: ScoutTeamCreateOneWithoutTeamDataInput
  submitter: UserCreateOneInput!
}

input TeamDataCreateManyInput {
  create: [TeamDataCreateInput!]
  connect: [TeamDataWhereUniqueInput!]
}

input TeamDataCreateManyWithoutOwnerInput {
  create: [TeamDataCreateWithoutOwnerInput!]
  connect: [TeamDataWhereUniqueInput!]
}

input TeamDataCreateWithoutOwnerInput {
  name: String!
  value: String!
  private: Boolean
  submitter: UserCreateOneInput!
}

type TeamDataEdge {
  node: TeamData!
  cursor: String!
}

enum TeamDataOrderByInput {
  name_ASC
  name_DESC
  value_ASC
  value_DESC
  private_ASC
  private_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  id_ASC
  id_DESC
}

type TeamDataPreviousValues {
  name: String!
  value: String!
  private: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamDataSubscriptionPayload {
  mutation: MutationType!
  node: TeamData
  updatedFields: [String!]
  previousValues: TeamDataPreviousValues
}

input TeamDataSubscriptionWhereInput {
  AND: [TeamDataSubscriptionWhereInput!]
  OR: [TeamDataSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamDataWhereInput
}

input TeamDataUpdateInput {
  name: String
  value: String
  private: Boolean
  owner: ScoutTeamUpdateOneWithoutTeamDataInput
  submitter: UserUpdateOneInput
}

input TeamDataUpdateManyInput {
  create: [TeamDataCreateInput!]
  connect: [TeamDataWhereUniqueInput!]
  disconnect: [TeamDataWhereUniqueInput!]
  delete: [TeamDataWhereUniqueInput!]
}

input TeamDataUpdateManyWithoutOwnerInput {
  create: [TeamDataCreateWithoutOwnerInput!]
  connect: [TeamDataWhereUniqueInput!]
  disconnect: [TeamDataWhereUniqueInput!]
  delete: [TeamDataWhereUniqueInput!]
  update: [TeamDataUpdateWithoutOwnerInput!]
  upsert: [TeamDataUpsertWithoutOwnerInput!]
}

input TeamDataUpdateWithoutOwnerDataInput {
  name: String
  value: String
  private: Boolean
  submitter: UserUpdateOneInput
}

input TeamDataUpdateWithoutOwnerInput {
  where: TeamDataWhereUniqueInput!
  data: TeamDataUpdateWithoutOwnerDataInput!
}

input TeamDataUpsertWithoutOwnerInput {
  where: TeamDataWhereUniqueInput!
  update: TeamDataUpdateWithoutOwnerDataInput!
  create: TeamDataCreateWithoutOwnerInput!
}

input TeamDataWhereInput {
  AND: [TeamDataWhereInput!]
  OR: [TeamDataWhereInput!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  private: Boolean
  private_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  owner: ScoutTeamWhereInput
  submitter: UserWhereInput
}

input TeamDataWhereUniqueInput {
  name: String
}

type TeamEdge {
  node: Team!
  cursor: String!
}

type TeamField {
  name: String!
  type: FieldType!
  private: Boolean
  submitter(where: UserWhereInput): User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamFieldConnection {
  pageInfo: PageInfo!
  edges: [TeamFieldEdge]!
  aggregate: AggregateTeamField!
}

input TeamFieldCreateInput {
  name: String!
  type: FieldType!
  private: Boolean
  submitter: UserCreateOneInput!
}

input TeamFieldCreateManyInput {
  create: [TeamFieldCreateInput!]
  connect: [TeamFieldWhereUniqueInput!]
}

type TeamFieldEdge {
  node: TeamField!
  cursor: String!
}

enum TeamFieldOrderByInput {
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  private_ASC
  private_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  id_ASC
  id_DESC
}

type TeamFieldPreviousValues {
  name: String!
  type: FieldType!
  private: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamFieldSubscriptionPayload {
  mutation: MutationType!
  node: TeamField
  updatedFields: [String!]
  previousValues: TeamFieldPreviousValues
}

input TeamFieldSubscriptionWhereInput {
  AND: [TeamFieldSubscriptionWhereInput!]
  OR: [TeamFieldSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamFieldWhereInput
}

input TeamFieldUpdateInput {
  name: String
  type: FieldType
  private: Boolean
  submitter: UserUpdateOneInput
}

input TeamFieldUpdateManyInput {
  create: [TeamFieldCreateInput!]
  connect: [TeamFieldWhereUniqueInput!]
  disconnect: [TeamFieldWhereUniqueInput!]
  delete: [TeamFieldWhereUniqueInput!]
}

input TeamFieldWhereInput {
  AND: [TeamFieldWhereInput!]
  OR: [TeamFieldWhereInput!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: FieldType
  type_not: FieldType
  type_in: [FieldType!]
  type_not_in: [FieldType!]
  private: Boolean
  private_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  submitter: UserWhereInput
}

input TeamFieldWhereUniqueInput {
  name: String
}

enum TeamOrderByInput {
  number_ASC
  number_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TeamPreviousValues {
  number: Int!
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
}

input TeamUpdateInput {
  number: Int
  competitions: CompetitionUpdateManyWithoutTeamsInput
  matches: MatchPlacementUpdateManyWithoutTeamInput
  teamData: TeamDataUpdateManyInput
  matchData: MatchDataUpdateManyWithoutTeamInput
}

input TeamUpdateManyWithoutCompetitionsInput {
  create: [TeamCreateWithoutCompetitionsInput!]
  connect: [TeamWhereUniqueInput!]
  disconnect: [TeamWhereUniqueInput!]
  delete: [TeamWhereUniqueInput!]
  update: [TeamUpdateWithoutCompetitionsInput!]
  upsert: [TeamUpsertWithoutCompetitionsInput!]
}

input TeamUpdateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
  disconnect: TeamWhereUniqueInput
  delete: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutMatchDataInput {
  create: TeamCreateWithoutMatchDataInput
  connect: TeamWhereUniqueInput
  disconnect: TeamWhereUniqueInput
  delete: TeamWhereUniqueInput
  update: TeamUpdateWithoutMatchDataInput
  upsert: TeamUpsertWithoutMatchDataInput
}

input TeamUpdateOneWithoutMatchesInput {
  create: TeamCreateWithoutMatchesInput
  connect: TeamWhereUniqueInput
  disconnect: TeamWhereUniqueInput
  delete: TeamWhereUniqueInput
  update: TeamUpdateWithoutMatchesInput
  upsert: TeamUpsertWithoutMatchesInput
}

input TeamUpdateWithoutCompetitionsDataInput {
  number: Int
  matches: MatchPlacementUpdateManyWithoutTeamInput
  teamData: TeamDataUpdateManyInput
  matchData: MatchDataUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutCompetitionsInput {
  where: TeamWhereUniqueInput!
  data: TeamUpdateWithoutCompetitionsDataInput!
}

input TeamUpdateWithoutMatchDataDataInput {
  number: Int
  competitions: CompetitionUpdateManyWithoutTeamsInput
  matches: MatchPlacementUpdateManyWithoutTeamInput
  teamData: TeamDataUpdateManyInput
}

input TeamUpdateWithoutMatchDataInput {
  where: TeamWhereUniqueInput!
  data: TeamUpdateWithoutMatchDataDataInput!
}

input TeamUpdateWithoutMatchesDataInput {
  number: Int
  competitions: CompetitionUpdateManyWithoutTeamsInput
  teamData: TeamDataUpdateManyInput
  matchData: MatchDataUpdateManyWithoutTeamInput
}

input TeamUpdateWithoutMatchesInput {
  where: TeamWhereUniqueInput!
  data: TeamUpdateWithoutMatchesDataInput!
}

input TeamUpsertWithoutCompetitionsInput {
  where: TeamWhereUniqueInput!
  update: TeamUpdateWithoutCompetitionsDataInput!
  create: TeamCreateWithoutCompetitionsInput!
}

input TeamUpsertWithoutMatchDataInput {
  where: TeamWhereUniqueInput!
  update: TeamUpdateWithoutMatchDataDataInput!
  create: TeamCreateWithoutMatchDataInput!
}

input TeamUpsertWithoutMatchesInput {
  where: TeamWhereUniqueInput!
  update: TeamUpdateWithoutMatchesDataInput!
  create: TeamCreateWithoutMatchesInput!
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  competitions_every: CompetitionWhereInput
  competitions_some: CompetitionWhereInput
  competitions_none: CompetitionWhereInput
  matches_every: MatchPlacementWhereInput
  matches_some: MatchPlacementWhereInput
  matches_none: MatchPlacementWhereInput
  teamData_every: TeamDataWhereInput
  teamData_some: TeamDataWhereInput
  teamData_none: TeamDataWhereInput
  matchData_every: MatchDataWhereInput
  matchData_some: MatchDataWhereInput
  matchData_none: MatchDataWhereInput
}

input TeamWhereUniqueInput {
  number: Int
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  password: String!
  name: String!
  roles: UserCreaterolesInput
  scoutTeam: ScoutTeamCreateOneWithoutMembersInput
}

input UserCreateManyWithoutScoutTeamInput {
  create: [UserCreateWithoutScoutTeamInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreaterolesInput {
  set: [Role!]
}

input UserCreateWithoutScoutTeamInput {
  email: String!
  password: String!
  name: String!
  roles: UserCreaterolesInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  name: String!
  roles: [Role!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  roles: UserUpdaterolesInput
  scoutTeam: ScoutTeamUpdateOneWithoutMembersInput
}

input UserUpdateManyWithoutScoutTeamInput {
  create: [UserCreateWithoutScoutTeamInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithoutScoutTeamInput!]
  upsert: [UserUpsertWithoutScoutTeamInput!]
}

input UserUpdateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  disconnect: UserWhereUniqueInput
  delete: UserWhereUniqueInput
}

input UserUpdaterolesInput {
  set: [Role!]
}

input UserUpdateWithoutScoutTeamDataInput {
  email: String
  password: String
  name: String
  roles: UserUpdaterolesInput
}

input UserUpdateWithoutScoutTeamInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutScoutTeamDataInput!
}

input UserUpsertWithoutScoutTeamInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutScoutTeamDataInput!
  create: UserCreateWithoutScoutTeamInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  scoutTeam: ScoutTeamWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
